<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bitcoin Core: ankerl::nanobench Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bitcoin_logo_doxygen.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bitcoin Core<span id="projectnumber">&#160;22.99.0</span>
   </div>
   <div id="projectbrief">P2P Digital Currency</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceankerl.html">ankerl</a></li><li class="navelem"><a class="el" href="namespaceankerl_1_1nanobench.html">nanobench</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ankerl::nanobench Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceankerl_1_1nanobench_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceankerl_1_1nanobench_1_1templates"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench_1_1templates.html">templates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main entry point to nanobench's benchmarking facility.  <a href="classankerl_1_1nanobench_1_1_bench.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">BigO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structankerl_1_1nanobench_1_1_config.html">Config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classankerl_1_1nanobench_1_1_rng.html">Rng</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An extremely fast random generator.  <a href="classankerl_1_1nanobench_1_1_rng.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a70372b52c9daba60286ba24bc9d89bd5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#a70372b52c9daba60286ba24bc9d89bd5">Clock</a> = std::conditional&lt; std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock, std::chrono::steady_clock &gt;::type</td></tr>
<tr class="separator:a70372b52c9daba60286ba24bc9d89bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a23321de52edde793127736a4bf9abe50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#a23321de52edde793127736a4bf9abe50">render</a> (char const *mustacheTemplate, <a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;bench, std::ostream &amp;out)</td></tr>
<tr class="memdesc:a23321de52edde793127736a4bf9abe50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renders output from a mustache-like template and benchmark results.  <a href="namespaceankerl_1_1nanobench.html#a23321de52edde793127736a4bf9abe50">More...</a><br /></td></tr>
<tr class="separator:a23321de52edde793127736a4bf9abe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d9695a0f769c889d54ee935de09db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#ac8d9695a0f769c889d54ee935de09db6">render</a> (std::string const &amp;mustacheTemplate, <a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;bench, std::ostream &amp;out)</td></tr>
<tr class="separator:ac8d9695a0f769c889d54ee935de09db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c6dbcea3a980d60c721209f779585b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#a24c6dbcea3a980d60c721209f779585b">render</a> (char const *mustacheTemplate, std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;results, std::ostream &amp;out)</td></tr>
<tr class="memdesc:a24c6dbcea3a980d60c721209f779585b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="namespaceankerl_1_1nanobench.html#a23321de52edde793127736a4bf9abe50" title="Renders output from a mustache-like template and benchmark results.">render(char const* mustacheTemplate, Bench const&amp; bench, std::ostream&amp; out)</a>, but for when you only have results available.  <a href="namespaceankerl_1_1nanobench.html#a24c6dbcea3a980d60c721209f779585b">More...</a><br /></td></tr>
<tr class="separator:a24c6dbcea3a980d60c721209f779585b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3eae894395a7479879e1d59fcd9431"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#a9a3eae894395a7479879e1d59fcd9431">render</a> (std::string const &amp;mustacheTemplate, std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;results, std::ostream &amp;out)</td></tr>
<tr class="separator:a9a3eae894395a7479879e1d59fcd9431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae575ef6845f3cd10a30c17a4a5fd7e"><td class="memTemplParams" colspan="2">template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:afae575ef6845f3cd10a30c17a4a5fd7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#afae575ef6845f3cd10a30c17a4a5fd7e">doNotOptimizeAway</a> (Arg &amp;&amp;arg)</td></tr>
<tr class="memdesc:afae575ef6845f3cd10a30c17a4a5fd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure none of the given arguments are optimized away by the compiler.  <a href="namespaceankerl_1_1nanobench.html#afae575ef6845f3cd10a30c17a4a5fd7e">More...</a><br /></td></tr>
<tr class="separator:afae575ef6845f3cd10a30c17a4a5fd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb12dc96844dc4155aa42c8d23c75d1"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#a9bb12dc96844dc4155aa42c8d23c75d1">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">BigO</a> const &amp;bigO)</td></tr>
<tr class="separator:a9bb12dc96844dc4155aa42c8d23c75d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa786a1ad7235179883d4ba008d8bea70"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceankerl_1_1nanobench.html#aa786a1ad7235179883d4ba008d8bea70">operator&lt;&lt;</a> (std::ostream &amp;os, std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">ankerl::nanobench::BigO</a> &gt; const &amp;bigOs)</td></tr>
<tr class="separator:aa786a1ad7235179883d4ba008d8bea70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a70372b52c9daba60286ba24bc9d89bd5" name="a70372b52c9daba60286ba24bc9d89bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70372b52c9daba60286ba24bc9d89bd5">&#9670;&nbsp;</a></span>Clock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceankerl_1_1nanobench.html#a70372b52c9daba60286ba24bc9d89bd5">ankerl::nanobench::Clock</a> = typedef std::conditional&lt;std::chrono::high_resolution_clock::is_steady, std::chrono::high_resolution_clock, std::chrono::steady_clock&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="nanobench_8h_source.html#l00127">127</a> of file <a class="el" href="nanobench_8h_source.html">nanobench.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="afae575ef6845f3cd10a30c17a4a5fd7e" name="afae575ef6845f3cd10a30c17a4a5fd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae575ef6845f3cd10a30c17a4a5fd7e">&#9670;&nbsp;</a></span>doNotOptimizeAway()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ankerl::nanobench::doNotOptimizeAway </td>
          <td>(</td>
          <td class="paramtype">Arg &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes sure none of the given arguments are optimized away by the compiler. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Type of the argument that shouldn't be optimized away. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>The input that we mark as being used, even though we don't do anything with it. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="nanobench_8h_source.html#l01228">1228</a> of file <a class="el" href="nanobench_8h_source.html">nanobench.h</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceankerl_1_1nanobench_afae575ef6845f3cd10a30c17a4a5fd7e_cgraph.svg" width="416" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="namespaceankerl_1_1nanobench_afae575ef6845f3cd10a30c17a4a5fd7e_icgraph.svg" width="402" height="88"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a9bb12dc96844dc4155aa42c8d23c75d1" name="a9bb12dc96844dc4155aa42c8d23c75d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb12dc96844dc4155aa42c8d23c75d1">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ankerl::nanobench::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">BigO</a> const &amp;&#160;</td>
          <td class="paramname"><em>bigO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa786a1ad7235179883d4ba008d8bea70" name="aa786a1ad7235179883d4ba008d8bea70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa786a1ad7235179883d4ba008d8bea70">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; ankerl::nanobench::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_big_o.html">ankerl::nanobench::BigO</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>bigOs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23321de52edde793127736a4bf9abe50" name="a23321de52edde793127736a4bf9abe50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23321de52edde793127736a4bf9abe50">&#9670;&nbsp;</a></span>render() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ankerl::nanobench::render </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>mustacheTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;&#160;</td>
          <td class="paramname"><em>bench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renders output from a mustache-like template and benchmark results. </p>
<p >The templating facility here is heavily inspired by <a href="https://mustache.github.io/">mustache - logic-less templates</a>. It adds a few more features that are necessary to get all of the captured data out of nanobench. Please read the excellent <a href="https://mustache.github.io/mustache.5.html">mustache manual</a> to see what this is all about.</p>
<p >nanobench output has two nested layers, <em>result</em> and <em>measurement</em>. Here is a hierarchy of the allowed tags:</p>
<ul>
<li><p class="startli"><code>{{#result}}</code> Marks the begin of the result layer. Whatever comes after this will be instantiated as often as a benchmark result is available. Within it, you can use these tags:</p><ul>
<li><code>{{title}}</code> See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#afcfcd633d537e11bc1874f8f3c8b0fd3" title="Title of the benchmark, will be shown in the table header.">Bench::title()</a>.</li>
<li><code>{{name}}</code> Benchmark name, usually directly provided with <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a396e218813c7eeb20a58adad9bbd85f7" title="Repeatedly calls op() based on the configuration, and performs measurements.">Bench::run()</a>, but can also be set with <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a5d2c176976630636ecd8a1fd6bed24aa" title="Name of the benchmark, will be shown in the table row.">Bench::name()</a>.</li>
<li><code>{{unit}}</code> Unit, e.g. <code>byte</code>. Defaults to <code>op</code>, see <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#afcfcd633d537e11bc1874f8f3c8b0fd3" title="Title of the benchmark, will be shown in the table header.">Bench::title()</a>.</li>
<li><code>{{batch}}</code> Batch size, see <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a2ad3cec90b4b5dba041a47373419e8bd" title="Sets the batch size.">Bench::batch()</a>.</li>
<li><code>{{complexityN}}</code> Value used for asymptotic complexity calculation. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a0027b7d43a3eafb3311b8b74a749dede">Bench::complexityN()</a>.</li>
<li><code>{{epochs}}</code> Number of epochs, see <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a5795648d6235b578ca71ce38b787ec81" title="Controls number of epochs, the number of measurements to perform.">Bench::epochs()</a>.</li>
<li><code>{{clockResolution}}</code> Accuracy of the clock, i.e. what's the smallest time possible to measure with the clock. For modern systems, this can be around 20 ns. This value is automatically determined by nanobench at the first benchmark that is run, and used as a static variable throughout the application's runtime.</li>
<li><code>{{clockResolutionMultiple}}</code> Configuration multiplier for <code>clockResolution</code>. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a72614738bf60b31859d3f14271961239" title="Modern processors have a very accurate clock, being able to measure as low as 20 nanoseconds.">Bench::clockResolutionMultiple()</a>. This is the target runtime for each measurement (epoch). That means the more accurate your clock is, the faster will be the benchmark. Basing the measurement's runtime on the clock resolution is the main reason why nanobench is so fast.</li>
<li><code>{{maxEpochTime}}</code> Configuration for a maximum time each measurement (epoch) is allowed to take. Note that at least a single iteration will be performed, even when that takes longer than maxEpochTime. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#aef7bbd7a1f059dda0e03ed47748b8f13" title="Upper limit for the runtime of each epoch.">Bench::maxEpochTime()</a>.</li>
<li><code>{{minEpochTime}}</code> Minimum epoch time, usually not set. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#af9f510fd53cff860d150fff1ea0ec82e" title="Minimum time each epoch should take.">Bench::minEpochTime()</a>.</li>
<li><code>{{minEpochIterations}}</code> See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a88842c3e9dffecbd7a5061e65fd609ab" title="Sets the minimum number of iterations each epoch should take.">Bench::minEpochIterations()</a>.</li>
<li><code>{{epochIterations}}</code> See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#afb83c3694a8f494c19d3114162fc9ebb" title="Sets exactly the number of iterations for each epoch.">Bench::epochIterations()</a>.</li>
<li><code>{{warmup}}</code> Number of iterations used before measuring starts. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#a09d1947386503bddf1d34fe7d0338e98" title="Sets a number of iterations that are initially performed without any measurements.">Bench::warmup()</a>.</li>
<li><code>{{relative}}</code> True or false, depending on the setting you have used. See <a class="el" href="classankerl_1_1nanobench_1_1_bench.html#afccbfce7dfbf7506410392f5ad096597" title="Marks the next run as the baseline.">Bench::relative()</a>.</li>
</ul>
<p class="startli">Apart from these tags, it is also possible to use some mathematical operations on the measurement data. The operations are of the form <code>{{command(name)}}</code>. Currently <code>name</code> can be one of <code>elapsed</code>, <code>iterations</code>. If performance counters are available (currently only on current Linux systems), you also have <code>pagefaults</code>, <code>cpucycles</code>, <code>contextswitches</code>, <code>instructions</code>, <code>branchinstructions</code>, and <code>branchmisses</code>. All the measuers (except <code>iterations</code>) are provided for a single iteration (so <code>elapsed</code> is the time a single iteration took). The following tags are available:</p><ul>
<li><code>{{median(&lt;name&gt;)}}</code> Calculate median of a measurement data set, e.g. <code>{{median(elapsed)}}</code>.</li>
<li><code>{{average(&lt;name&gt;)}}</code> Average (mean) calculation.</li>
<li><p class="startli"><code>{{medianAbsolutePercentError(&lt;name&gt;)}}</code> Calculates MdAPE, the Median Absolute Percentage Error. The MdAPE is an excellent metric for the variation of measurements. It is more robust to outliers than the <a href="https://en.wikipedia.org/wiki/Mean_absolute_percentage_error">Mean absolute percentage error (M-APE)</a>. </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathrm{MdAPE}(e) = \mathrm{med}\{| \frac{e_i - \mathrm{med}\{e\}}{e_i}| \} \]" src="form_0.png"/>
</p>
<p> E.g. for <em>elapsed</em>: First, <img class="formulaInl" alt="$ \mathrm{med}\{e\} $" src="form_1.png"/> calculates the median by sorting and then taking the middle element of all <em>elapsed</em> measurements. This is used to calculate the absolute percentage error to this median for each measurement, as in <img class="formulaInl" alt="$ | \frac{e_i - \mathrm{med}\{e\}}{e_i}| $" src="form_2.png"/>. All these results are sorted, and the middle value is chosen as the median absolute percent error.</p>
<p class="startli">This measurement is a bit hard to interpret, but it is very robust against outliers. E.g. a value of 5% means that half of the measurements deviate less than 5% from the median, and the other deviate more than 5% from the median.</p>
</li>
<li><code>{{sum(&lt;name&gt;)}}</code> Sums of all the measurements. E.g. <code>{{sum(iterations)}}</code> will give you the total number of iterations measured in this benchmark.</li>
<li><code>{{minimum(&lt;name&gt;)}}</code> Minimum of all measurements.</li>
<li><code>{{maximum(&lt;name&gt;)}}</code> Maximum of all measurements.</li>
<li><code>{{sumProduct(&lt;first&gt;, &lt;second&gt;)}}</code> Calculates the sum of the products of corresponding measures: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ \mathrm{sumProduct}(a,b) = \sum_{i=1}^{n}a_i\cdot b_i \]" src="form_3.png"/>
</p>
 E.g. to calculate total runtime of the benchmark, you multiply iterations with elapsed time for each measurement, and sum these results up: <code>{{sumProduct(iterations, elapsed)}}</code>.</li>
<li><code>{{#measurement}}</code> To access individual measurement results, open the begin tag for measurements.<ul>
<li><code>{{elapsed}}</code> Average elapsed wall clock time per iteration, in seconds.</li>
<li><code>{{iterations}}</code> Number of iterations in the measurement. The number of iterations will fluctuate due to some applied randomness, to enhance accuracy.</li>
<li><code>{{pagefaults}}</code> Average number of pagefaults per iteration.</li>
<li><code>{{cpucycles}}</code> Average number of CPU cycles processed per iteration.</li>
<li><code>{{contextswitches}}</code> Average number of context switches per iteration.</li>
<li><code>{{instructions}}</code> Average number of retired instructions per iteration.</li>
<li><code>{{branchinstructions}}</code> Average number of branches executed per iteration.</li>
<li><code>{{branchmisses}}</code> Average number of branches that were missed per iteration.</li>
</ul>
</li>
<li><code>{{/measurement}}</code> Ends the measurement tag.</li>
</ul>
</li>
<li><p class="startli"><code>{{/result}}</code> Marks the end of the result layer. This is the end marker for the template part that will be instantiated for each benchmark result.</p>
<p class="startli">For the layer tags <em>result</em> and <em>measurement</em> you additionally can use these special markers:</p><ul>
<li><code>{{#-first}}</code> - Begin marker of a template that will be instantiated <em>only for the first</em> entry in the layer. Use is only allowed between the begin and end marker of the layer allowed. So between <code>{{#result}}</code> and <code>{{/result}}</code>, or between <code>{{#measurement}}</code> and <code>{{/measurement}}</code>. Finish the template with <code>{{/-first}}</code>.</li>
<li><code>{{^-first}}</code> - Begin marker of a template that will be instantiated <em>for each except the first</em> entry in the layer. This, this is basically the inversion of <code>{{#-first}}</code>. Use is only allowed between the begin and end marker of the layer allowed. So between <code>{{#result}}</code> and <code>{{/result}}</code>, or between <code>{{#measurement}}</code> and <code>{{/measurement}}</code>.</li>
<li><code>{{/-first}}</code> - End marker for either <code>{{#-first}}</code> or <code>{{^-first}}</code>.</li>
<li><code>{{#-last}}</code> - Begin marker of a template that will be instantiated <em>only for the last</em> entry in the layer. Use is only allowed between the begin and end marker of the layer allowed. So between <code>{{#result}}</code> and <code>{{/result}}</code>, or between <code>{{#measurement}}</code> and <code>{{/measurement}}</code>. Finish the template with <code>{{/-last}}</code>.</li>
<li><code>{{^-last}}</code> - Begin marker of a template that will be instantiated <em>for each except the last</em> entry in the layer. This, this is basically the inversion of <code>{{#-last}}</code>. Use is only allowed between the begin and end marker of the layer allowed. So between <code>{{#result}}</code> and <code>{{/result}}</code>, or between <code>{{#measurement}}</code> and <code>{{/measurement}}</code>.</li>
<li><code>{{/-last}}</code> - End marker for either <code>{{#-last}}</code> or <code>{{^-last}}</code>.</li>
</ul>
</li>
</ul>
<pre class="fragment">embed:rst

For an overview of all the possible data you can get out of nanobench, please see the tutorial at :ref:`tutorial-template-json`.

The templates that ship with nanobench are:

* :cpp:func:`templates::csv() &lt;ankerl::nanobench::templates::csv()&gt;`
* :cpp:func:`templates::json() &lt;ankerl::nanobench::templates::json()&gt;`
* :cpp:func:`templates::htmlBoxplot() &lt;ankerl::nanobench::templates::htmlBoxplot()&gt;`
* :cpp:func:`templates::pyperf() &lt;ankerl::nanobench::templates::pyperf()&gt;`</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mustacheTemplate</td><td>The template. </td></tr>
    <tr><td class="paramname">bench</td><td>Benchmark, containing all the results. </td></tr>
    <tr><td class="paramname">out</td><td>Output for the generated output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24c6dbcea3a980d60c721209f779585b" name="a24c6dbcea3a980d60c721209f779585b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c6dbcea3a980d60c721209f779585b">&#9670;&nbsp;</a></span>render() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ankerl::nanobench::render </td>
          <td>(</td>
          <td class="paramtype">char const *&#160;</td>
          <td class="paramname"><em>mustacheTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="namespaceankerl_1_1nanobench.html#a23321de52edde793127736a4bf9abe50" title="Renders output from a mustache-like template and benchmark results.">render(char const* mustacheTemplate, Bench const&amp; bench, std::ostream&amp; out)</a>, but for when you only have results available. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mustacheTemplate</td><td>The template. </td></tr>
    <tr><td class="paramname">results</td><td>All the results to be used for rendering. </td></tr>
    <tr><td class="paramname">out</td><td>Output for the generated output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8d9695a0f769c889d54ee935de09db6" name="ac8d9695a0f769c889d54ee935de09db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8d9695a0f769c889d54ee935de09db6">&#9670;&nbsp;</a></span>render() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ankerl::nanobench::render </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>mustacheTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classankerl_1_1nanobench_1_1_bench.html">Bench</a> const &amp;&#160;</td>
          <td class="paramname"><em>bench</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a3eae894395a7479879e1d59fcd9431" name="a9a3eae894395a7479879e1d59fcd9431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3eae894395a7479879e1d59fcd9431">&#9670;&nbsp;</a></span>render() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ankerl::nanobench::render </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>mustacheTemplate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classankerl_1_1nanobench_1_1_result.html">Result</a> &gt; const &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 8 2021 14:20:12 for Bitcoin Core by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
