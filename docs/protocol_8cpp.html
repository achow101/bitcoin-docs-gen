<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Bitcoin Core: src/protocol.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="bitcoin_logo_doxygen.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Bitcoin Core<span id="projectnumber">&#160;22.99.0</span>
   </div>
   <div id="projectbrief">P2P Digital Currency</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">protocol.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="protocol_8h_source.html">protocol.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="system_8h_source.html">util/system.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for protocol.cpp:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp__incl.svg" width="4107" height="575"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
</div>
<p><a href="protocol_8cpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_net_msg_type"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html">NetMsgType</a></td></tr>
<tr class="memdesc:namespace_net_msg_type"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitcoin protocol message types. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8eb4b78a3323a45f8553d598f30a9753"><td class="memItemLeft" align="right" valign="top">static std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a8eb4b78a3323a45f8553d598f30a9753">g_initial_block_download_completed</a> (false)</td></tr>
<tr class="separator:a8eb4b78a3323a45f8553d598f30a9753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f422dd198f0c99c343a18f2b2367a"><td class="memItemLeft" align="right" valign="top">static const std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a267f422dd198f0c99c343a18f2b2367a">allNetMessageTypesVec</a> (std::begin(<a class="el" href="protocol_8cpp.html#ac3dc59483df8c59dff51850f6289c754">allNetMessageTypes</a>), std::end(<a class="el" href="protocol_8cpp.html#ac3dc59483df8c59dff51850f6289c754">allNetMessageTypes</a>))</td></tr>
<tr class="separator:a267f422dd198f0c99c343a18f2b2367a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a92bd3e5b80138a55fafae4c4770ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="protocol_8h.html#ad131f3177584caea787cdbf6f85a9537">ServiceFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a4a92bd3e5b80138a55fafae4c4770ecd">GetDesirableServiceFlags</a> (<a class="el" href="protocol_8h.html#ad131f3177584caea787cdbf6f85a9537">ServiceFlags</a> services)</td></tr>
<tr class="memdesc:a4a92bd3e5b80138a55fafae4c4770ecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the set of service flags which are "desirable" for a given peer.  <a href="protocol_8cpp.html#a4a92bd3e5b80138a55fafae4c4770ecd">More...</a><br /></td></tr>
<tr class="separator:a4a92bd3e5b80138a55fafae4c4770ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7cb231a14c1ace5268df7f7793529e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a1b7cb231a14c1ace5268df7f7793529e">SetServiceFlagsIBDCache</a> (bool state)</td></tr>
<tr class="memdesc:a1b7cb231a14c1ace5268df7f7793529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current IBD status in order to figure out the desirable service flags.  <a href="protocol_8cpp.html#a1b7cb231a14c1ace5268df7f7793529e">More...</a><br /></td></tr>
<tr class="separator:a1b7cb231a14c1ace5268df7f7793529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2684809000d3a0523769ad7585ace197"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a2684809000d3a0523769ad7585ace197">operator&lt;</a> (const <a class="el" href="class_c_inv.html">CInv</a> &amp;a, const <a class="el" href="class_c_inv.html">CInv</a> &amp;b)</td></tr>
<tr class="separator:a2684809000d3a0523769ad7585ace197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c01c7e36a89c678f6dacd287d1dfb7a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a0c01c7e36a89c678f6dacd287d1dfb7a">getAllNetMessageTypes</a> ()</td></tr>
<tr class="separator:a0c01c7e36a89c678f6dacd287d1dfb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a2adcdb648d6473610b0c049981526"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a61a2adcdb648d6473610b0c049981526">serviceFlagToStr</a> (size_t bit)</td></tr>
<tr class="memdesc:a61a2adcdb648d6473610b0c049981526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a service flag (NODE_*) to a human readable string.  <a href="protocol_8cpp.html#a61a2adcdb648d6473610b0c049981526">More...</a><br /></td></tr>
<tr class="separator:a61a2adcdb648d6473610b0c049981526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e821db595250233ecdc8827991d066e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a3e821db595250233ecdc8827991d066e">serviceFlagsToStr</a> (uint64_t <a class="el" href="bitcoin-tx_8cpp.html#ac8bf36fe0577cba66bccda3a6f7e80a4">flags</a>)</td></tr>
<tr class="memdesc:a3e821db595250233ecdc8827991d066e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert service flags (a bitmask of NODE_*) to human readable strings.  <a href="protocol_8cpp.html#a3e821db595250233ecdc8827991d066e">More...</a><br /></td></tr>
<tr class="separator:a3e821db595250233ecdc8827991d066e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3466d64f79e3865dc16910ed3d1ba3d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gen_txid.html">GenTxid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#a3466d64f79e3865dc16910ed3d1ba3d8">ToGenTxid</a> (const <a class="el" href="class_c_inv.html">CInv</a> &amp;inv)</td></tr>
<tr class="memdesc:a3466d64f79e3865dc16910ed3d1ba3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a TX/WITNESS_TX/WTX <a class="el" href="class_c_inv.html" title="inv message data">CInv</a> to a <a class="el" href="class_gen_txid.html" title="A generic txid reference (txid or wtxid).">GenTxid</a>.  <a href="protocol_8cpp.html#a3466d64f79e3865dc16910ed3d1ba3d8">More...</a><br /></td></tr>
<tr class="separator:a3466d64f79e3865dc16910ed3d1ba3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a79d16fca661ece8c17e786943721fd34"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a79d16fca661ece8c17e786943721fd34">NetMsgType::VERSION</a> =&quot;version&quot;</td></tr>
<tr class="memdesc:a79d16fca661ece8c17e786943721fd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">The version message provides information about the transmitting node to the receiving node at the beginning of a connection.  <a href="namespace_net_msg_type.html#a79d16fca661ece8c17e786943721fd34">More...</a><br /></td></tr>
<tr class="separator:a79d16fca661ece8c17e786943721fd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8228cc7b3374862bcb3d79f5ff38e6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#aaf8228cc7b3374862bcb3d79f5ff38e6">NetMsgType::VERACK</a> =&quot;verack&quot;</td></tr>
<tr class="memdesc:aaf8228cc7b3374862bcb3d79f5ff38e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The verack message acknowledges a previously-received version message, informing the connecting node that it can begin to send other messages.  <a href="namespace_net_msg_type.html#aaf8228cc7b3374862bcb3d79f5ff38e6">More...</a><br /></td></tr>
<tr class="separator:aaf8228cc7b3374862bcb3d79f5ff38e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d83bbf95702906ee01ca4fd934e1c0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a77d83bbf95702906ee01ca4fd934e1c0">NetMsgType::ADDR</a> =&quot;addr&quot;</td></tr>
<tr class="memdesc:a77d83bbf95702906ee01ca4fd934e1c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addr (IP address) message relays connection information for peers on the network.  <a href="namespace_net_msg_type.html#a77d83bbf95702906ee01ca4fd934e1c0">More...</a><br /></td></tr>
<tr class="separator:a77d83bbf95702906ee01ca4fd934e1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339caa4772c5fa2abbecd67d93a8f6b8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a339caa4772c5fa2abbecd67d93a8f6b8">NetMsgType::ADDRV2</a> =&quot;addrv2&quot;</td></tr>
<tr class="memdesc:a339caa4772c5fa2abbecd67d93a8f6b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The addrv2 message relays connection information for peers on the network just like the addr message, but is extended to allow gossiping of longer node addresses (see BIP155).  <a href="namespace_net_msg_type.html#a339caa4772c5fa2abbecd67d93a8f6b8">More...</a><br /></td></tr>
<tr class="separator:a339caa4772c5fa2abbecd67d93a8f6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8b1121b481a323754e80fc34e23ffa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#acc8b1121b481a323754e80fc34e23ffa">NetMsgType::SENDADDRV2</a> =&quot;sendaddrv2&quot;</td></tr>
<tr class="memdesc:acc8b1121b481a323754e80fc34e23ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sendaddrv2 message signals support for receiving ADDRV2 messages (BIP155).  <a href="namespace_net_msg_type.html#acc8b1121b481a323754e80fc34e23ffa">More...</a><br /></td></tr>
<tr class="separator:acc8b1121b481a323754e80fc34e23ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabe3cd738cb766597ff4c1ee1e47cbd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#afabe3cd738cb766597ff4c1ee1e47cbd">NetMsgType::INV</a> =&quot;inv&quot;</td></tr>
<tr class="memdesc:afabe3cd738cb766597ff4c1ee1e47cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inv message (inventory message) transmits one or more inventories of objects known to the transmitting peer.  <a href="namespace_net_msg_type.html#afabe3cd738cb766597ff4c1ee1e47cbd">More...</a><br /></td></tr>
<tr class="separator:afabe3cd738cb766597ff4c1ee1e47cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53772dc0dfe3dc5a6ac2c99444a2afe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#aa53772dc0dfe3dc5a6ac2c99444a2afe">NetMsgType::GETDATA</a> =&quot;getdata&quot;</td></tr>
<tr class="memdesc:aa53772dc0dfe3dc5a6ac2c99444a2afe"><td class="mdescLeft">&#160;</td><td class="mdescRight">The getdata message requests one or more data objects from another node.  <a href="namespace_net_msg_type.html#aa53772dc0dfe3dc5a6ac2c99444a2afe">More...</a><br /></td></tr>
<tr class="separator:aa53772dc0dfe3dc5a6ac2c99444a2afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5af2ea09090341213f7021f7741e929"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#ae5af2ea09090341213f7021f7741e929">NetMsgType::MERKLEBLOCK</a> =&quot;merkleblock&quot;</td></tr>
<tr class="memdesc:ae5af2ea09090341213f7021f7741e929"><td class="mdescLeft">&#160;</td><td class="mdescRight">The merkleblock message is a reply to a getdata message which requested a block using the inventory type MSG_MERKLEBLOCK.  <a href="namespace_net_msg_type.html#ae5af2ea09090341213f7021f7741e929">More...</a><br /></td></tr>
<tr class="separator:ae5af2ea09090341213f7021f7741e929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a51f1ef81fa21178b6e241937934fed"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a7a51f1ef81fa21178b6e241937934fed">NetMsgType::GETBLOCKS</a> =&quot;getblocks&quot;</td></tr>
<tr class="memdesc:a7a51f1ef81fa21178b6e241937934fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The getblocks message requests an inv message that provides block header hashes starting from a particular point in the block chain.  <a href="namespace_net_msg_type.html#a7a51f1ef81fa21178b6e241937934fed">More...</a><br /></td></tr>
<tr class="separator:a7a51f1ef81fa21178b6e241937934fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6abd72d04b4128a949c0c4db11d883"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a9f6abd72d04b4128a949c0c4db11d883">NetMsgType::GETHEADERS</a> =&quot;getheaders&quot;</td></tr>
<tr class="memdesc:a9f6abd72d04b4128a949c0c4db11d883"><td class="mdescLeft">&#160;</td><td class="mdescRight">The getheaders message requests a headers message that provides block headers starting from a particular point in the block chain.  <a href="namespace_net_msg_type.html#a9f6abd72d04b4128a949c0c4db11d883">More...</a><br /></td></tr>
<tr class="separator:a9f6abd72d04b4128a949c0c4db11d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ab96e2e9fa2a1b1655f0034667604d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a75ab96e2e9fa2a1b1655f0034667604d">NetMsgType::TX</a> =&quot;tx&quot;</td></tr>
<tr class="memdesc:a75ab96e2e9fa2a1b1655f0034667604d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tx message transmits a single transaction.  <a href="namespace_net_msg_type.html#a75ab96e2e9fa2a1b1655f0034667604d">More...</a><br /></td></tr>
<tr class="separator:a75ab96e2e9fa2a1b1655f0034667604d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216e35db319a5d508043639fd3170776"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a216e35db319a5d508043639fd3170776">NetMsgType::HEADERS</a> =&quot;headers&quot;</td></tr>
<tr class="memdesc:a216e35db319a5d508043639fd3170776"><td class="mdescLeft">&#160;</td><td class="mdescRight">The headers message sends one or more block headers to a node which previously requested certain headers with a getheaders message.  <a href="namespace_net_msg_type.html#a216e35db319a5d508043639fd3170776">More...</a><br /></td></tr>
<tr class="separator:a216e35db319a5d508043639fd3170776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1842ab3e065d8bc5180974b9e3f44377"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a1842ab3e065d8bc5180974b9e3f44377">NetMsgType::BLOCK</a> =&quot;block&quot;</td></tr>
<tr class="memdesc:a1842ab3e065d8bc5180974b9e3f44377"><td class="mdescLeft">&#160;</td><td class="mdescRight">The block message transmits a single serialized block.  <a href="namespace_net_msg_type.html#a1842ab3e065d8bc5180974b9e3f44377">More...</a><br /></td></tr>
<tr class="separator:a1842ab3e065d8bc5180974b9e3f44377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0f984b71f9e4c4b8b3619cb3f3dadd"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a4d0f984b71f9e4c4b8b3619cb3f3dadd">NetMsgType::GETADDR</a> =&quot;getaddr&quot;</td></tr>
<tr class="memdesc:a4d0f984b71f9e4c4b8b3619cb3f3dadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The getaddr message requests an addr message from the receiving node, preferably one with lots of IP addresses of other receiving nodes.  <a href="namespace_net_msg_type.html#a4d0f984b71f9e4c4b8b3619cb3f3dadd">More...</a><br /></td></tr>
<tr class="separator:a4d0f984b71f9e4c4b8b3619cb3f3dadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c340a8ef4f949cfd06c19a620aa32c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a68c340a8ef4f949cfd06c19a620aa32c">NetMsgType::MEMPOOL</a> =&quot;mempool&quot;</td></tr>
<tr class="memdesc:a68c340a8ef4f949cfd06c19a620aa32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mempool message requests the TXIDs of transactions that the receiving node has verified as valid but which have not yet appeared in a block.  <a href="namespace_net_msg_type.html#a68c340a8ef4f949cfd06c19a620aa32c">More...</a><br /></td></tr>
<tr class="separator:a68c340a8ef4f949cfd06c19a620aa32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a2ba0319f01bf1c26f5206b5156496"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#ad9a2ba0319f01bf1c26f5206b5156496">NetMsgType::PING</a> =&quot;ping&quot;</td></tr>
<tr class="memdesc:ad9a2ba0319f01bf1c26f5206b5156496"><td class="mdescLeft">&#160;</td><td class="mdescRight">The ping message is sent periodically to help confirm that the receiving peer is still connected.  <a href="namespace_net_msg_type.html#ad9a2ba0319f01bf1c26f5206b5156496">More...</a><br /></td></tr>
<tr class="separator:ad9a2ba0319f01bf1c26f5206b5156496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395de13511c6ef9946844ee280b8f08e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a395de13511c6ef9946844ee280b8f08e">NetMsgType::PONG</a> =&quot;pong&quot;</td></tr>
<tr class="memdesc:a395de13511c6ef9946844ee280b8f08e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The pong message replies to a ping message, proving to the pinging node that the ponging node is still alive.  <a href="namespace_net_msg_type.html#a395de13511c6ef9946844ee280b8f08e">More...</a><br /></td></tr>
<tr class="separator:a395de13511c6ef9946844ee280b8f08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567653d3f26a7e711889682e7fd1c484"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a567653d3f26a7e711889682e7fd1c484">NetMsgType::NOTFOUND</a> =&quot;notfound&quot;</td></tr>
<tr class="memdesc:a567653d3f26a7e711889682e7fd1c484"><td class="mdescLeft">&#160;</td><td class="mdescRight">The notfound message is a reply to a getdata message which requested an object the receiving node does not have available for relay.  <a href="namespace_net_msg_type.html#a567653d3f26a7e711889682e7fd1c484">More...</a><br /></td></tr>
<tr class="separator:a567653d3f26a7e711889682e7fd1c484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e95085c85cbbb8330fa1a5ffe49070f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a0e95085c85cbbb8330fa1a5ffe49070f">NetMsgType::FILTERLOAD</a> =&quot;filterload&quot;</td></tr>
<tr class="memdesc:a0e95085c85cbbb8330fa1a5ffe49070f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filterload message tells the receiving peer to filter all relayed transactions and requested merkle blocks through the provided filter.  <a href="namespace_net_msg_type.html#a0e95085c85cbbb8330fa1a5ffe49070f">More...</a><br /></td></tr>
<tr class="separator:a0e95085c85cbbb8330fa1a5ffe49070f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c8dba2361ddda663917c27f14c3a16"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a75c8dba2361ddda663917c27f14c3a16">NetMsgType::FILTERADD</a> =&quot;filteradd&quot;</td></tr>
<tr class="memdesc:a75c8dba2361ddda663917c27f14c3a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filteradd message tells the receiving peer to add a single element to a previously-set bloom filter, such as a new public key.  <a href="namespace_net_msg_type.html#a75c8dba2361ddda663917c27f14c3a16">More...</a><br /></td></tr>
<tr class="separator:a75c8dba2361ddda663917c27f14c3a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef3ccc1966cb35a59882fb97c15a30e"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a1ef3ccc1966cb35a59882fb97c15a30e">NetMsgType::FILTERCLEAR</a> =&quot;filterclear&quot;</td></tr>
<tr class="memdesc:a1ef3ccc1966cb35a59882fb97c15a30e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The filterclear message tells the receiving peer to remove a previously-set bloom filter.  <a href="namespace_net_msg_type.html#a1ef3ccc1966cb35a59882fb97c15a30e">More...</a><br /></td></tr>
<tr class="separator:a1ef3ccc1966cb35a59882fb97c15a30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f999f9e5179be5fc361aaca9c0e5b3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a34f999f9e5179be5fc361aaca9c0e5b3">NetMsgType::SENDHEADERS</a> =&quot;sendheaders&quot;</td></tr>
<tr class="memdesc:a34f999f9e5179be5fc361aaca9c0e5b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a node prefers to receive new block announcements via a "headers" message rather than an "inv".  <a href="namespace_net_msg_type.html#a34f999f9e5179be5fc361aaca9c0e5b3">More...</a><br /></td></tr>
<tr class="separator:a34f999f9e5179be5fc361aaca9c0e5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d555d376cad59629c5a640ba0eb2b3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a98d555d376cad59629c5a640ba0eb2b3">NetMsgType::FEEFILTER</a> =&quot;feefilter&quot;</td></tr>
<tr class="memdesc:a98d555d376cad59629c5a640ba0eb2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The feefilter message tells the receiving peer not to inv us any txs which do not meet the specified min fee rate.  <a href="namespace_net_msg_type.html#a98d555d376cad59629c5a640ba0eb2b3">More...</a><br /></td></tr>
<tr class="separator:a98d555d376cad59629c5a640ba0eb2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdafba4d585b4699628412c7f1c3d8b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a4cdafba4d585b4699628412c7f1c3d8b">NetMsgType::SENDCMPCT</a> =&quot;sendcmpct&quot;</td></tr>
<tr class="memdesc:a4cdafba4d585b4699628412c7f1c3d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a 1-byte bool and 8-byte LE version number.  <a href="namespace_net_msg_type.html#a4cdafba4d585b4699628412c7f1c3d8b">More...</a><br /></td></tr>
<tr class="separator:a4cdafba4d585b4699628412c7f1c3d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b20d74bd9d268e7d73be293bfe68b8a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a5b20d74bd9d268e7d73be293bfe68b8a">NetMsgType::CMPCTBLOCK</a> =&quot;cmpctblock&quot;</td></tr>
<tr class="memdesc:a5b20d74bd9d268e7d73be293bfe68b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a <a class="el" href="class_c_block_header_and_short_tx_i_ds.html">CBlockHeaderAndShortTxIDs</a> object - providing a header and list of "short txids".  <a href="namespace_net_msg_type.html#a5b20d74bd9d268e7d73be293bfe68b8a">More...</a><br /></td></tr>
<tr class="separator:a5b20d74bd9d268e7d73be293bfe68b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b6c7c7cc77f2f0b6af1949a6ee5920"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#af9b6c7c7cc77f2f0b6af1949a6ee5920">NetMsgType::GETBLOCKTXN</a> =&quot;getblocktxn&quot;</td></tr>
<tr class="memdesc:af9b6c7c7cc77f2f0b6af1949a6ee5920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a <a class="el" href="class_block_transactions_request.html">BlockTransactionsRequest</a> Peer should respond with "blocktxn" message.  <a href="namespace_net_msg_type.html#af9b6c7c7cc77f2f0b6af1949a6ee5920">More...</a><br /></td></tr>
<tr class="separator:af9b6c7c7cc77f2f0b6af1949a6ee5920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23245c939bfe57d37c0a2db68e05e05"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#ac23245c939bfe57d37c0a2db68e05e05">NetMsgType::BLOCKTXN</a> =&quot;blocktxn&quot;</td></tr>
<tr class="memdesc:ac23245c939bfe57d37c0a2db68e05e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a <a class="el" href="class_block_transactions.html">BlockTransactions</a>.  <a href="namespace_net_msg_type.html#ac23245c939bfe57d37c0a2db68e05e05">More...</a><br /></td></tr>
<tr class="separator:ac23245c939bfe57d37c0a2db68e05e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0b30fa48d172c25fb40d2c47f6d1ff"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a6c0b30fa48d172c25fb40d2c47f6d1ff">NetMsgType::GETCFILTERS</a> =&quot;getcfilters&quot;</td></tr>
<tr class="memdesc:a6c0b30fa48d172c25fb40d2c47f6d1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">getcfilters requests compact filters for a range of blocks.  <a href="namespace_net_msg_type.html#a6c0b30fa48d172c25fb40d2c47f6d1ff">More...</a><br /></td></tr>
<tr class="separator:a6c0b30fa48d172c25fb40d2c47f6d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b7ef2c310bd7360613dfb716306532"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a15b7ef2c310bd7360613dfb716306532">NetMsgType::CFILTER</a> =&quot;cfilter&quot;</td></tr>
<tr class="memdesc:a15b7ef2c310bd7360613dfb716306532"><td class="mdescLeft">&#160;</td><td class="mdescRight">cfilter is a response to a getcfilters request containing a single compact filter.  <a href="namespace_net_msg_type.html#a15b7ef2c310bd7360613dfb716306532">More...</a><br /></td></tr>
<tr class="separator:a15b7ef2c310bd7360613dfb716306532"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc283de38822908e99857f4230158ee3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#acc283de38822908e99857f4230158ee3">NetMsgType::GETCFHEADERS</a> =&quot;getcfheaders&quot;</td></tr>
<tr class="memdesc:acc283de38822908e99857f4230158ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">getcfheaders requests a compact filter header and the filter hashes for a range of blocks, which can then be used to reconstruct the filter headers for those blocks.  <a href="namespace_net_msg_type.html#acc283de38822908e99857f4230158ee3">More...</a><br /></td></tr>
<tr class="separator:acc283de38822908e99857f4230158ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f9f0e1d35e42669af4dc828e0204bad"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a0f9f0e1d35e42669af4dc828e0204bad">NetMsgType::CFHEADERS</a> =&quot;cfheaders&quot;</td></tr>
<tr class="memdesc:a0f9f0e1d35e42669af4dc828e0204bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">cfheaders is a response to a getcfheaders request containing a filter header and a vector of filter hashes for each subsequent block in the requested range.  <a href="namespace_net_msg_type.html#a0f9f0e1d35e42669af4dc828e0204bad">More...</a><br /></td></tr>
<tr class="separator:a0f9f0e1d35e42669af4dc828e0204bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500306b7c74a70a0709d6f9f61cae66a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#a500306b7c74a70a0709d6f9f61cae66a">NetMsgType::GETCFCHECKPT</a> =&quot;getcfcheckpt&quot;</td></tr>
<tr class="memdesc:a500306b7c74a70a0709d6f9f61cae66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">getcfcheckpt requests evenly spaced compact filter headers, enabling parallelized download and validation of the headers between them.  <a href="namespace_net_msg_type.html#a500306b7c74a70a0709d6f9f61cae66a">More...</a><br /></td></tr>
<tr class="separator:a500306b7c74a70a0709d6f9f61cae66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95de6c37c750e8790b97f934fa5e1e3"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#af95de6c37c750e8790b97f934fa5e1e3">NetMsgType::CFCHECKPT</a> =&quot;cfcheckpt&quot;</td></tr>
<tr class="memdesc:af95de6c37c750e8790b97f934fa5e1e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">cfcheckpt is a response to a getcfcheckpt request containing a vector of evenly spaced filter headers for blocks on the requested chain.  <a href="namespace_net_msg_type.html#af95de6c37c750e8790b97f934fa5e1e3">More...</a><br /></td></tr>
<tr class="separator:af95de6c37c750e8790b97f934fa5e1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54e607447f8d1333596436cbddf4150"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_net_msg_type.html#ad54e607447f8d1333596436cbddf4150">NetMsgType::WTXIDRELAY</a> =&quot;wtxidrelay&quot;</td></tr>
<tr class="memdesc:ad54e607447f8d1333596436cbddf4150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates that a node prefers to relay transactions via wtxid, rather than txid.  <a href="namespace_net_msg_type.html#ad54e607447f8d1333596436cbddf4150">More...</a><br /></td></tr>
<tr class="separator:ad54e607447f8d1333596436cbddf4150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc59483df8c59dff51850f6289c754"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="protocol_8cpp.html#ac3dc59483df8c59dff51850f6289c754">allNetMessageTypes</a> []</td></tr>
<tr class="memdesc:ac3dc59483df8c59dff51850f6289c754"><td class="mdescLeft">&#160;</td><td class="mdescRight">All known message types.  <a href="protocol_8cpp.html#ac3dc59483df8c59dff51850f6289c754">More...</a><br /></td></tr>
<tr class="separator:ac3dc59483df8c59dff51850f6289c754"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a267f422dd198f0c99c343a18f2b2367a" name="a267f422dd198f0c99c343a18f2b2367a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267f422dd198f0c99c343a18f2b2367a">&#9670;&nbsp;</a></span>allNetMessageTypesVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::vector&lt; std::string &gt; allNetMessageTypesVec </td>
          <td>(</td>
          <td class="paramtype">std::begin(<a class="el" href="protocol_8cpp.html#ac3dc59483df8c59dff51850f6289c754">allNetMessageTypes</a>)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::end(<a class="el" href="protocol_8cpp.html#ac3dc59483df8c59dff51850f6289c754">allNetMessageTypes</a>)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a267f422dd198f0c99c343a18f2b2367a_icgraph.svg" width="599" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a8eb4b78a3323a45f8553d598f30a9753" name="a8eb4b78a3323a45f8553d598f30a9753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eb4b78a3323a45f8553d598f30a9753">&#9670;&nbsp;</a></span>g_initial_block_download_completed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::atomic&lt; bool &gt; g_initial_block_download_completed </td>
          <td>(</td>
          <td class="paramtype">false&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a8eb4b78a3323a45f8553d598f30a9753_icgraph.svg" width="2300" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a0c01c7e36a89c678f6dacd287d1dfb7a" name="a0c01c7e36a89c678f6dacd287d1dfb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c01c7e36a89c678f6dacd287d1dfb7a">&#9670;&nbsp;</a></span>getAllNetMessageTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::string &gt; &amp; getAllNetMessageTypes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00179">179</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a0c01c7e36a89c678f6dacd287d1dfb7a_cgraph.svg" width="416" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a0c01c7e36a89c678f6dacd287d1dfb7a_icgraph.svg" width="372" height="104"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a4a92bd3e5b80138a55fafae4c4770ecd" name="a4a92bd3e5b80138a55fafae4c4770ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a92bd3e5b80138a55fafae4c4770ecd">&#9670;&nbsp;</a></span>GetDesirableServiceFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="protocol_8h.html#ad131f3177584caea787cdbf6f85a9537">ServiceFlags</a> GetDesirableServiceFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="protocol_8h.html#ad131f3177584caea787cdbf6f85a9537">ServiceFlags</a>&#160;</td>
          <td class="paramname"><em>services</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the set of service flags which are "desirable" for a given peer. </p>
<p >These are the flags which are required for a peer to support for them to be "interesting" to us, ie for us to wish to use one of our few outbound connection slots for or for us to wish to prioritize keeping their connection around.</p>
<p >Relevant service flags may be peer- and state-specific in that the version of the peer may determine which flags are required (eg in the case of NODE_NETWORK_LIMITED where we seek out NODE_NETWORK peers unless they set NODE_NETWORK_LIMITED and we are out of IBD, in which case NODE_NETWORK_LIMITED suffices).</p>
<p >Thus, generally, avoid calling with peerServices == NODE_NONE, unless state-specific flags must absolutely be avoided. When called with peerServices == NODE_NONE, the returned desirable service flags are guaranteed to not change dependent on state - ie they are suitable for use when describing peers which we know to be desirable, but for which we do not have a confirmed set of service flags.</p>
<p >If the NODE_NONE return value is changed, contrib/seeds/makeseeds.py should be updated appropriately to filter for the same nodes. </p>

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00127">127</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a4a92bd3e5b80138a55fafae4c4770ecd_cgraph.svg" width="436" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a4a92bd3e5b80138a55fafae4c4770ecd_icgraph.svg" width="2066" height="206"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a2684809000d3a0523769ad7585ace197" name="a2684809000d3a0523769ad7585ace197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2684809000d3a0523769ad7585ace197">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_inv.html">CInv</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_c_inv.html">CInv</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00146">146</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>

</div>
</div>
<a id="a3e821db595250233ecdc8827991d066e" name="a3e821db595250233ecdc8827991d066e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e821db595250233ecdc8827991d066e">&#9670;&nbsp;</a></span>serviceFlagsToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; serviceFlagsToStr </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert service flags (a bitmask of NODE_*) to human readable strings. </p>
<p >It supports unknown service flags which will be returned as "UNKNOWN[...]". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>multiple NODE_* bitwise-OR-ed together </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00210">210</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a3e821db595250233ecdc8827991d066e_cgraph.svg" width="324" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a3e821db595250233ecdc8827991d066e_icgraph.svg" width="2775" height="223"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a61a2adcdb648d6473610b0c049981526" name="a61a2adcdb648d6473610b0c049981526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a2adcdb648d6473610b0c049981526">&#9670;&nbsp;</a></span>serviceFlagToStr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string serviceFlagToStr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a service flag (NODE_*) to a human readable string. </p>
<p >It supports unknown service flags which will be returned as "UNKNOWN[...]". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>the service flag is calculated as (1 &lt;&lt; bit) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00189">189</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a61a2adcdb648d6473610b0c049981526_icgraph.svg" width="2952" height="223"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a1b7cb231a14c1ace5268df7f7793529e" name="a1b7cb231a14c1ace5268df7f7793529e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7cb231a14c1ace5268df7f7793529e">&#9670;&nbsp;</a></span>SetServiceFlagsIBDCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetServiceFlagsIBDCache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current IBD status in order to figure out the desirable service flags. </p>

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00134">134</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a1b7cb231a14c1ace5268df7f7793529e_cgraph.svg" width="435" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a3466d64f79e3865dc16910ed3d1ba3d8" name="a3466d64f79e3865dc16910ed3d1ba3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3466d64f79e3865dc16910ed3d1ba3d8">&#9670;&nbsp;</a></span>ToGenTxid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gen_txid.html">GenTxid</a> ToGenTxid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_c_inv.html">CInv</a> &amp;&#160;</td>
          <td class="paramname"><em>inv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a TX/WITNESS_TX/WTX <a class="el" href="class_c_inv.html" title="inv message data">CInv</a> to a <a class="el" href="class_gen_txid.html" title="A generic txid reference (txid or wtxid).">GenTxid</a>. </p>

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00223">223</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a3466d64f79e3865dc16910ed3d1ba3d8_cgraph.svg" width="288" height="240"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="protocol_8cpp_a3466d64f79e3865dc16910ed3d1ba3d8_icgraph.svg" width="547" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac3dc59483df8c59dff51850f6289c754" name="ac3dc59483df8c59dff51850f6289c754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3dc59483df8c59dff51850f6289c754">&#9670;&nbsp;</a></span>allNetMessageTypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string allNetMessageTypes[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All known message types. </p>
<p >Keep this in the same order as the list of messages above and in protocol.h. </p>

<p class="definition">Definition at line <a class="el" href="protocol_8cpp_source.html#l00052">52</a> of file <a class="el" href="protocol_8cpp_source.html">protocol.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 8 2021 14:20:08 for Bitcoin Core by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
